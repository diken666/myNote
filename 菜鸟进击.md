1. 函数柯里化：慢慢凑齐参数，延迟函数的执行（先分期交钱，再交货）
```js
// ⚠️ 函数的length属性，表示该函数有多少个必须要传入的参数，及第一个默认参数前的所有参数

// 概念版
const curry = (fn, arr = []) => {
  return (...args) => {
    // 判断总参数是否与fn参数个数相等
    if ([...arr, ...args].length === fn.length) {
      return fn(...arr, ...args) // 扩展参数，调用fn
    } else {
      return curry(fn,[...arr, ...args]) //迭代，传入现有的所有参数
    }
  }
}
 
 // 最终版
const curry = ( fn, arr = []) => {
  return (...args) => {
    return ( a => a.length === fn.length ? fn(...a) : curry(fn, a))([...arr, ...args])
  }
}
let curryPlus = curry((a,b,c,d)=>a+b+c+d)
curryPlus(1,2,3)(4) //返回10
curryPlus(1,2)(4)(3) //返回10
curryPlus(1,2)(3,4) //返回10

```

2. call、apply、bind三兄弟
> 1. 接收的第一个参数都是要绑定的this的指向
> 2. apply的第二个参数是一个参数数组，call和bind后的参数作为实参按顺序传入
> 3. bind不会立即调用，其它两个会

⚠️  call和apply，在严格模式下，函数this的值就是call和apply的的第一个参数的值，非严格模式下，第一个参数的值指定为null或者undefined时，this会自动替换指向全局对象，原始值会自动包装

```js
const developer = {
  getSkills: function(...args) {
    console.log(...args)
  }
}
const webDeveloper = {
  skills: ['html']
}
	
developer.getSkills.call(webDeveloper, 'h5', 'css3', 'js')
developer.getSkills.apply(webDeveloper, ['h5', 'css3', 'js'])
developer.getSkills.bind(webDeveloper)( 'h5', 'css3', 'js')
// 或者
developer.getSkills.bind(webDeveloper, 'h5', 'css3', 'js')()
```
3. 在局部作用域下，`undefined`是可以修改值的，所以局部作用域下，判断一个变量是否为`undefined`，更严谨的方法是 `typeof a === 'undefined'` 或者 `a === void(0)` 

🚩 为啥使用 `void` ?  void通常用于获取undefined的原始值，一般使用 `void(0)`或者`void 0`，因为`void`是不能被重写的 🌟  
🚩 全局作用域下，undefined不能被修改实际上是，`window.undefined`不能被修改，因为浏览器下任何全局变量都是在window下的，`let undefined = 3`会提示已经被定义
```js
function test() {
  let undefined = 3
  console.log(undefined)
}
test() // 3
```
4. HTTP 1.0/1.1/2.0 了解
> 相关链接：
>> [1.1和2.0的性能区别](https://http2.akamai.com/demo)  
>> [HTTP/2 相比 1.0 有哪些重大改进？](https://www.zhihu.com/question/34074946)

> HTTP 1.0特点：  
>> 1. 规定浏览器和服务器直接只能保持`短暂连接`，每次请求都要建立一个`TCP`连接，完成后立即断开，文件请求较多时，频繁建立和关闭连接比较费时
>> 2. 不跟踪每个用户，也不记录过去的请求，1.0 被抱怨最多的就是 `🌟连接无法复用`和`🌟head of line blocking（线头阻塞）`
>> 3. tips: `连接无法复用`会导致每次请求都经历三次握手和慢启动，三次握手在高延迟环境下影响明显，慢启动会对大文件请求影响较大。`线头阻塞`会导致带宽无法充分利用，后续健康请求被阻塞

> HTTP 1.1特点： 
>> 1. `支持持久连接`
>> 2. 可以一个TCP上可以传送多个HTTP请求和响应，允许客户端不用等待上一个请求结果返回，就可以发送下一次请求，但服务端必须按顺序响应结果，但是这个Pipelining在浏览器中是默认关闭的，因为 一些服务器不能正确处理 HPPT Pipelining，正确的流水线实现是很复杂的，如果某个请求花费太多时间，容易发生`线头阻塞`
>> 3. tips: 浏览器可以对同一Host的tcp请求的数量做限制，chrome为最多同时6个

> HTTP 2.0特点：重要概念就是`流`和`帧`，帧属流，一TCP中多流，解决了以往的`串行文件传输`和`连接数过多`的问题
>
> > 1. `多路复用`：允许同时通过单一的 HTTP/2连接发起多重的请求-响应消息，实现多流并行而不依赖建立多个TCP连接
> > 2. `二进制分帧`：在应用层(HTTP/2)和传输层(TCP or UDP)之间增加一个二进制分帧层，将所有传输的信息分割为更小的消息和帧（frame）,并对它们采用二进制格式的编码 ，其中 HTTP1.x 的首部信息会被封装到 HEADER frame，而相应的 Request Body 则封装到 DATA frame 里面
> > 3. `首部压缩`
> > 4. `服务端推送`

5. HTTPS 加密握手过程，过程如下: 
![流程图](./images/HTTPS握手流程.png)
> HTTP有哪些缺点？ 无法保证消息的`保密性` `完整性` `准确性` `可靠性`，用明文在浏览器和服务器间传递信息  
> HTTPS 采用`对称加密`和`非对称加密`结合的方式，`对称加密算法加密数据`+`非对称加密算法交换密钥`+`数字证书验证身份`=`安全`

6. 关于vue中列表组件中使用key的讨论
> 1. vue在渲染列表的时候，采用就地复用的策略，如果dom的顺序修改，vue不会对dom的顺序做修改，而是复用当前元素，如 a,b,c,d,e中 bc间插入f，那么不带key的情况下，对照关系为 a->a, b->b, f->c, c->d, d->e, e
> 2. 官方文档中也提及：建议尽可能在使用 v-for 时提供 key，除非遍历输出的` DOM 内容非常简单`，或者是`刻意依赖默认行为以获取性能上的提升`。因为它是 Vue 识别节点的一个通用机制，key 并不与 v-for 特别关联，key 还具有其他用途。

  - 不用key：
  > 1. 就地复用节点
  > 2. 无法维持组件状态
  > 3. 可能带来性能下降  

  - 用key：
  > 1. 维持组件状态，保证组件复用
  > 2. 查找性能上提升
  > 3. 节点复用带来的性能提升

7. `['1', '2', '3'].map(parseInt)` 返回什么 ？why ？[MDN中map定义](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map) [MDN中parseInt定义](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseInt)
```js
['1', '2', '3'].map(parseInt) // [1,NaN,NaN]
// 首先了解map中函数中参数，
// arr.map(function callback(currentValue, index, array)
// currentValue: 正在处理的当前函数
// index: 当前元素的索引
// array: 调用map方法的数组

// 再来看parseInt的参数
// parseInt(string, radix)
// string: 要被解析的值，如果不是字符串 会被转化为字符串
// radix: 一个介于2到36的的整数，在radix为undefined或0或未指定情况下，加遵守如下规则：
// 1. 如果字符串 string 以"0x"或者"0X"开头, 则基数是16 (16进制)
// 2. 如果字符串 string 以"0"开头, 基数是8（八进制）或者10（十进制），那么具体是哪个基数由实现环境决定。ECMAScript 5 规定使用10，但是并不是所有的浏览器都遵循这个规定。因此，永远都要明确给出radix参数的值
// 3. 如果字符串 string 以其它任何值开头，则基数是10 (十进制)

// 所以 上述函数 相当于执行 如下
['1', '2', '3'].map((item, index) => {
  return parseInt(item, index)
})
// 依次返回 parseInt('1', 0)，parseInt('2', 1)，parseInt('3', 2)
// 所以返回[1, NaN, NaN]
```

8. 什么是防抖和节流？有何区别？如何实现？
> 1. 防抖：n秒内函数只会执行一次，如果n秒内再次触发，则重新计算时间
> > 思路：每次事件触发事件就取消之前的延时调用
> ```js
> function debounce(fn) {
>   let timeout = null;
>   return function() {
>     clearTimeout(timeout);
>     timeout = setTimeout(() => {
>       fn.apply(this, arguments)
>     }, 500) 
>   }
> }
> ```
> 2. 节流：n秒内只会触发一次，节流会稀释函数的执行频率
> > 思路：每次触发事件时，都判断当前是否有等待执行的延迟函数
> ```js
> function throttle(fn) {
>   let canRun = true;
>   return function () {
>     if (!canRun) return;
>     canRun = false;
>     setTimeout(() => {
>       fn.apply(this, arguments)
>       canRun = true
>     }, 500)
>   }
> }
> ```

9. Set, Map, WeakSet和WeakMap的区别，[ECMAScript 6 入门中的描述](https://es6.ruanyifeng.com/#docs/set-map)
> 1. Set：成员不能重复，只有键值，没有键名，类似数组（length变为size），可枚举，有`add`  `delete` `has` `clear`等方法，`Array.from`方法可以将Set结构转化为数组
> 2. WeakSet：将弱引用对象储存在一个集合中，`只能存放对象引用，不能存放值`，有`add` `has` `delete`方法
> 3. Map：构建时应传入可枚举对象，类似对象，键名不再局限于自字符串，有`set` `get` `delete` `has` `clear` 等方法，有size属性，遍历map用[key, value] of map, 或者 forEach((value, key) => {})
> 4. WeakMap：和Map类似，但是其中的`键是弱引用`对象，值可以是任意的，因为可能被垃圾回收，所以`WeakMap的key是不可枚举的`，有`has` `get` `set` `delete`等方法

10. JS运行机制：
> - 执行流程图如下
> > ![Event Loop事件循环](./images/EventLoop事件循环.png)
> > 1. 整体的script(作为第一个宏任务)开始执行的时候，会把所有代码分为两部分：“同步任务”、“异步任务”
> > 2. 同步任务会直接进入主线程依次执行
> > 3. 异步任务会再分为宏任务和微任务
> > 4. 宏任务进入到Event Table中，并在里面注册回调函数，每当指定的事件完成时，Event Table会将这个函数移到Event Queue中
> > 5. 微任务也会进入到另一个Event Table中，并在里面注册回调函数，每当指定的事件完成时，Event Table会将这个函数移到Event Queue中
> > 6. 当主线程内的任务执行完毕，主线程为空时，会检查微任务的Event Queue，如果有任务，就全部执行，如果没有就执行下一个宏任务
> > 7. 上述过程会不断重复，这就是Event Loop事件循环
> - 关于`同步任务`和`异步任务`
> > 1. 同步任务：在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务
> > 2. 异步任务：不进入主线程，而进入“任务队列”，只有任务队列通知主线程，某个异步任务可以执行了，该任务才会到主线程中执行。  
> > ⚠️  `new Promise`会进入主线程立即执行，`Promise.then()`则属于`微任务`  
> > ⚠️  同样注意`async/await`，async函数返回的是一个Promise，所以在`await`行及以上内容会立即执行，await后的内容则相当于`promise.then`里的内容，属于微任务
> - 关于`Microtask`和`Macrotask/task`
> > 1. Microtask 微任务
> > - process.nexrtTick
> > - promise.then
> > - Object.observe(废弃)
> > - MutationObserver
> > 2. Macrotask 宏任务
> > - setTimeout / setInterval
> > - setImmediate
> > - I/O
> > - UI渲染

11. 有`var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10];`数组，要求数组扁平化并去除其中重复数据，最终得到一个升序且不重复的数组
> ```js
> // 首先要用到Array.flat()函数
> // flat()方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。
> 
> // 1. 先扁平化处理
> let tempArr = arr.flat(Infinity)
> // 2. 去重
> let tempSet = new Set(tempArr)
> // 3. 转为数组 再排序
> Array.from(tempSet).sort((a,b) => a - b)
> // 简化合并后
> Array.from(new Set(arr.flat(Infinity))).sort((a, b) => a - b)
> ```

12. `Object.create` 创建一个新对象，使用现有的对象来提供新创建的对象的`__proto__`，[MDN上说明](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create)， 关于`__proto__`属性，是用来读取或设置当前对象的prototype对象，目前只有浏览器环境下必须要部署这个属性。
> 参数：
> > - `proto` 必选， 新创建的原型对象
> > - `propertiesObject` 可选，需要传入一个对象，对象属性类型参照[Object.defineProperties](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties)，如果该参数不为`undefined`，该传入对象的自有可枚举属性（及其自身的定义属性，而不是其原型链上的枚举属性）将为新创建的对象添加指定的属性值和对应的属性描述符
> ```js
> let testObj = Object.create({}, {a: { value: 123 }, b: { value: "123" }})
> // 注意区分 new Object() 和 Object.create()的区别
> let a = { test: 123 }
> let b = new Object(a)
> let c = Object.create(a)
> b.hasOwnProperty("test")  // true
> b.__proto__ === Object.prototype // true
> c.hasOwnProperty("test")  // false
> c.__proto__  // { test: 123 }
> 
> // 延伸，如何显示一个new功能
> function (fn, ...arg) {
>   const obj = Object.create(fn.prototype)
>   const ret = fn.apply(obj, arg);
>   // ⚠️ 因为Object.create(null)创建的对象是不继承Object原型链上的属性的
>   // ⚠️ 通过 {} 和 new Object()创建的对象是一样是要继承的
>   // instanceof 用于检测构造函数的prototype属性是否出现在某个实例对象的原型链上
>   return ret instanceof Object ? ret : obj
> }
> 
> ```

13. TCP的三次握手和四次挥手理解
> - 流程如下图
> ![握手和挥手图](./images/TCP的三次握手和四次挥手.png)

14. 三种判断数组的方法和优劣：`Object.prototype.toString.call()`、`instanceof `、`Array.isArray()`
> 1. `Object.prototype.toString.call()`，适用范围最广
> ```js
> let a = []
> Object.prototype.toString.call(a) // [object Array]
> 
> Object.prototype.toString.call(1) // "[object Number]"
> Object.prototype.toString.call(Symbol(1)) // "[object Symbol]"
> Object.prototype.toString.call(null) // "[object Null]"
> Object.prototype.toString.call(undefined) // "[object Undefined]"
> ```
> 2. `instanceof`，它会在该对象的原型链上找对应的`Array`的原型
> ```js
> [] instanceof Array // true
> [] instanceof Object // true
> ```
> 3. `Array.isArray()`，性能最好，但要考虑兼容性

15. 浏览器渲染原理：JavaScript引擎是基于事件驱动单线程执行的，渲染线程负责渲染浏览器界面，但是GUI渲染线程与JS引擎是互斥的，当JS引擎执行时GUI线程会被挂起，GUI的更新也会被保存在一个队列中，等到JS引擎空闲时才有机会被执行，当浏览器获取HTML文件后，会自上而下加载并在加载过程中进行解析和渲染；加载就是获取资源的过程；`如果在加载过程中遇到外部的css文件和图片，浏览器会另外发送一个请求，去获取css文件和图片，这个请求是异步的，并不会影响HTML文件的加载；但如果遇到JavaScript文件，HTML文件会挂起渲染的进程`，等待JavaScript文件加载完毕后，再继续进行渲染
> 总体流程：`解析html` -> `构建DOM树` -> `构建CSSOM树` -> `构建渲染树` -> `布局` -> `绘制`
> 常见问题
>
> 1. 为什么要等待JS？
> > 因为JS可能会修改DOM，导致后面的HTML资源白白渲染，需要等待JS文件加载完成后，再继续渲染
> 2. CSS加载会阻塞页面显示吗？
> > 1. 不会阻塞DOM树的解析
> > 2. 会阻塞DOM树的渲染
> > 3. 会阻塞后面JS的语句的运行

16. 回流和重绘：

17. `观察者模式`和`发布订阅模式`的差异:

![差异图](./images/观察者模式和发布订阅模式的区别.png)
> 文字总结：
>
> > 1. 观察者模式中，观察者是知道Subject的。发布订阅模式中，发布者和订阅者是不知道对方存在的，只能通过消息代理
> > 2. 发布订阅模式中，组件是松散耦合的
> > 3. 观察者模式 大多数时候是同步的，发布订阅模式 大多是异步的
> >
> 高亮回答： 观察者模式中没有中间商，发布订阅模式有

18. 理解`vertical-align`和`line-height`的小细节，[参考链接](https://www.zhangxinxu.com/wordpress/2015/08/css-deep-understand-vertical-align-and-line-height/?shrink=1)
> 总结： 一个`inline-block`元素，如果里面的没有行内元素，或者overflow不为visible，则该元素的基线就是其margin底部的下边缘，否则就是最后一行内联元素的基线
>
> 其它：
> 1. vertical-align的默认值是`baseline`，且它只对行内元素起作用，对块级元素无感
> 2. vertical-align: middle的居中不是绝对的居中，是近似居中，因为是以文本的中线位置情况来的，如下图所示
>
> ![vertical-align:middle近似居中](./images/vertical-align_middle近似居中.png)
>
> 3. 可用`font-size: 0`来去掉内联元素的空白
> ```css
> /* vertical-align和line-height的联系 */
> {
> 	line-height: 30px; 
> 	vertical-align: -10%;
> }
> /* 等于如下 */
> {
> 	line-height: 30px; 
> 	vertical-align: -3px;
> }
> ```

19. `const`和`let`声明的变量不在`window`上，用`var`和`function`声明的变量和方法会出现在`window`上
20. 将数组`['A1', 'A2', 'B1', 'B2', 'C1', 'C2', 'D1', 'D2']`和数组`['A', 'B', 'C', 'D']`合并为`["A1", "A2", "A", "B1", "B2", "B", "C1", "C2", "C", "D1", "D2", "D"]`
```js
  // 方法1 （思路：将b数组加入大的标志值，合并排序后再清除标志值）
  let a = ['A1', 'A2', 'B1', 'B2', 'C1', 'C2', 'D1', 'D2'];
  let b = ['A', 'B', 'C', 'D'].map(item => item + '3');
  let res = [...a, ...b].sort().map(item => {
    if (item.includes('3')) return item.replace('3', '')
    return item
  })
  // 方法2 (思路：遍历a数组，当遇到要插入位置时，及尾号为2时，插入b数组元素，最后数组压平处理)
  let a = ['A1', 'A2', 'B1', 'B2', 'C1', 'C2', 'D1', 'D2'];
  let b = ['A', 'B', 'C', 'D'];
  let copyB = b;
  let res = a.map(item => {
    if (item.charAt(1) === '2') {
      return [item, copyB.shift()]
    }
    return item;
  }).flat();
  
````
21. `token`和`cookie`：
> 1. token不是用来防止`XSS(跨站脚本攻击)`，而是用来防止`CRSF(跨站请求伪造)`
> 2. CRFS的原因是浏览器会自动带上cookie，而不会自动带上`token`

22. vue中`defineProperty`和`Proxy`和区别：
> 一句话：Proxy能够劫持整个对象，而defineProperty只能劫持设置的对象属性，多了一层遍历
> ```js
> // defineProperty
> let obj = {};
> Object.defineProperty(obj, "name", {
> 	enumerable: true,
> 	set(value) {
> 		console.log("设置值了");
> 		_name = value
> 	},
> 	get() {
> 		console.log("取值了");
> 		return _name
> 	}
> })
> obj.age = 12; // 将不会提示
> 
> // Proxy
> let objProxy = new Proxy(obj, {
> 	get(obj, prop) {
> 		console.log("取值了");
> 		return obj[prop]
> 	},
> 	set(obj, prop, value) {
> 		console.log("设置值了");
> 		obj[prop] = value;
> 	}
> })
> objProxy.test = 123; // 会提示设置值了，obj中会出现test属性
> 
> ```

23. 下面函数的输出是？一句话`具名自执行函数，函数名可读且不能修改(const理解)`
```js
var b = 10;
(function b() {
  b = 20;
  console.log(b)
})();

// 输出如下：
// ƒ b() {
//  b = 20;
//  console.log(b)
// }

// 原因
// 内部作用域，会先去查找是有已有变量b的声明，有就直接赋值20，确实有了呀。发现了具名函数 function b(){}，拿此b做赋值；
// IIFE的函数无法进行赋值（内部机制，类似const定义的常量），所以无效。
```

24. 使用迭代方式实现`flat`函数
```js
// 1. 迭代方式
const arr = [1, 2, [3, 4]]
function flatten(arr) {
	while (arr.some(item => Array.isArray(item))) {
		arr = [].concat(...arr)
	}
	return arr
}
// some() 方法测试数组中是不是至少有1个元素通过了被提供的函数测试。它返回的是一个Boolean类型的值。

// 2. 递归方式
function flatten(arr) {
	let resArr = [];
	arr.forEach(item => {
		if (Array.isArray(item)) {
			resArr.push(...flatten(item));
		} else {
			resArr.push(item);
		}
	})
	return resArr
}
// 3. 字符串转换
arr.join(",").split(",").map(item => Number(item))
```

25. 下列代码什么情况下会打印1 ?
```js
var a;
if (a == 1 && a == 2 && a ==3) {
	console.log(1);
}

// 1. ==符号会进行隐式转换，所以可以改写toString 或者 valueOf方法
var a = {
	i: 0,
	// 转化为数字类型时 优先调用 valueOf
	valueOf() {
		return a.i++;
	},
	toString() {
		return a.i++;
	}
}

// 2. 如果a是数组，用数组的shift方法覆盖toString方法
var a = [1, 2, 3];
a.toString = a.shift

// 3. 可以用Symbal.toPrimitive
var a = {
	[Symbal.toPrimitive]: ((i) => () => i++)(0)
}
```

> 知识点：
> > 1. `toString`和`valueOf`的区别：
> > > toString：将对象的原始值以字符串形式返回
> > > valueOf： 返回最适合该对象的原始值
> > > 在数值运算中会优先调用`valueOf`，如 a + b
> > > 在字符串运算中会优先调用`toString`, 如 alert(a)
> >
> > 2. `Symbal.toPrimitive` 是一个内置的 Symbol 值，它是作为对象的函数值属性存在的，当一个对象转换为对应的原始值时，会调用此函数。[参看MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toPrimitive)

26. 了解BFC， `block formatting content(块级格式化上下文)`，具有BFC特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，[知乎文章参考](https://zhuanlan.zhihu.com/p/25321647)，[MDN文档参考](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flow_Layout/Intro_to_formatting_contexts)
> 只要元素满足下面任一条，即可触发BFC特性
> 1. html根元素（body不行）
> 2. 浮动元素：float 除 none 以外的值
> 3. 绝对定位元素：position (absolute、fixed)
> 4. display 为 inline-block、table-cells、flex
> 5. （🌟 最常用）overflow 除了 visible 以外的值 (hidden、auto、scroll) 
> - BFC特性及应用
> >  1. 同一个 BFC 下外边距会发生折叠
> >  2. BFC 可以包含浮动的元素（清除浮动）
> >  3. BFC 可以阻止元素被浮动元素覆盖

27. `React`复习知识点: 
> 1,  避免在`componentWillMount`中调用`setState`，因为该周期函数发生在`render`之前，这里设置`state`，是不会触发重新渲染的
>
> 2. 在react中手动添加的事件监听，需要在组件卸载时清除，否则会造成`内存泄漏`
> 3. 不传参时，函数绑定可以如下写: `<button onClick={::this.click}></button>`

