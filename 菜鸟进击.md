1. 函数柯里化：慢慢凑齐参数，延迟函数的执行（先分期交钱，再交货）
```js
// ⚠️ 函数的length属性，表示该函数有多少个必须要传入的参数，及第一个默认参数前的所有参数

// 概念版
const curry = (fn, arr = []) => {
  return (...args) => {
    // 判断总参数是否与fn参数个数相等
    if ([...arr, ...args].length === fn.length) {
      return fn(...arr, ...args) // 扩展参数，调用fn
    } else {
      return curry(fn,[...arr, ...args]) //迭代，传入现有的所有参数
    }
  }
}
 
 // 最终版
const curry = ( fn, arr = []) => {
  return (...args) => {
    return ( a => a.length === fn.length ? fn(...a) : curry(fn, a))([...arr, ...args])
  }
}
let curryPlus = curry((a,b,c,d)=>a+b+c+d)
curryPlus(1,2,3)(4) //返回10
curryPlus(1,2)(4)(3) //返回10
curryPlus(1,2)(3,4) //返回10

```

2. call、apply、bind三兄弟
> 1. 接收的第一个参数都是要绑定的this的指向
> 2. apply的第二个参数是一个参数数组，call和bind后的参数作为实参按顺序传入
> 3. bind不会立即调用，其它两个会

⚠️  call和apply，在严格模式下，函数this的值就是call和apply的的第一个参数的值，非严格模式下，第一个参数的值指定为null或者undefined时，this会自动替换指向全局对象，原始值会自动包装

```js
const developer = {
  getSkills: function(...args) {
    console.log(...args)
  }
}
const webDeveloper = {
  skills: ['html']
}
	
developer.getSkills.call(webDeveloper, 'h5', 'css3', 'js')
developer.getSkills.apply(webDeveloper, ['h5', 'css3', 'js'])
developer.getSkills.bind(webDeveloper)( 'h5', 'css3', 'js')
// 或者
developer.getSkills.bind(webDeveloper, 'h5', 'css3', 'js')()
```
3. 在局部作用域下，`undefined`是可以修改值的，所以局部作用域下，判断一个变量是否为`undefined`，更严谨的方法是 `typeof a === 'undefined'` 或者 `a === void(0)` 

🚩 为啥使用 `void` ?  void通常用于获取undefined的原始值，一般使用 `void(0)`或者`void 0`，因为`void`是不能被重写的 🌟  
🚩 全局作用域下，undefined不能被修改实际上是，`window.undefined`不能被修改，因为浏览器下任何全局变量都是在window下的，`let undefined = 3`会提示已经被定义
```js
function test() {
  let undefined = 3
  console.log(undefined)
}
test() // 3
```
4. HTTP 1.0/1.1/2.0 了解
> 相关链接：
>> [1.1和2.0的性能区别](https://http2.akamai.com/demo)  
>> [HTTP/2 相比 1.0 有哪些重大改进？](https://www.zhihu.com/question/34074946)

> HTTP 1.0特点：  
>> 1. 规定浏览器和服务器直接只能保持`短暂连接`，每次请求都要建立一个`TCP`连接，完成后立即断开，文件请求较多时，频繁建立和关闭连接比较费时
>> 2. 不跟踪每个用户，也不记录过去的请求，1.0 被抱怨最多的就是 `🌟连接无法复用`和`🌟head of line blocking（线头阻塞）`
>> 3. tips: `连接无法复用`会导致每次请求都经历三次握手和慢启动，三次握手在高延迟环境下影响明显，慢启动会对大文件请求影响较大。`线头阻塞`会导致带宽无法充分利用，后续健康请求被阻塞

> HTTP 1.1特点： 
>> 1. `支持持久连接`
>> 2. 可以一个TCP上可以传送多个HTTP请求和响应，允许客户端不用等待上一个请求结果返回，就可以发送下一次请求，但服务端必须按顺序响应结果，但是这个Pipelining在浏览器中是默认关闭的，因为 一些服务器不能正确处理 HPPT Pipelining，正确的流水线实现是很复杂的，如果某个请求花费太多时间，容易发生`线头阻塞`
>> 3. tips: 浏览器可以对同一Host的tcp请求的数量做限制，chrome为最多同时6个

> HTTP 2.0特点：重要概念就是`流`和`帧`，帧属流，一TCP中多流，解决了以往的`串行文件传输`和`连接数过多`的问题
>
> > 1. `多路复用`：允许同时通过单一的 HTTP/2连接发起多重的请求-响应消息，实现多流并行而不依赖建立多个TCP连接
> > 2. `二进制分帧`：在应用层(HTTP/2)和传输层(TCP or UDP)之间增加一个二进制分帧层，将所有传输的信息分割为更小的消息和帧（frame）,并对它们采用二进制格式的编码 ，其中 HTTP1.x 的首部信息会被封装到 HEADER frame，而相应的 Request Body 则封装到 DATA frame 里面
> > 3. `首部压缩`
> > 4. `服务端推送`

5. HTTPS 加密握手过程，过程如下: 
![流程图](./images/HTTPS握手流程.png)
> HTTP有哪些缺点？ 无法保证消息的`保密性` `完整性` `准确性` `可靠性`，用明文在浏览器和服务器间传递信息  
> HTTPS 采用`对称加密`和`非对称加密`结合的方式，`对称加密算法加密数据`+`非对称加密算法交换密钥`+`数字证书验证身份`=`安全`

6. 关于vue中列表组件中使用key的讨论
> 1. vue在渲染列表的时候，采用就地复用的策略，如果dom的顺序修改，vue不会对dom的顺序做修改，而是复用当前元素，如 a,b,c,d,e中 bc间插入f，那么不带key的情况下，对照关系为 a->a, b->b, f->c, c->d, d->e, e
> 2. 官方文档中也提及：建议尽可能在使用 v-for 时提供 key，除非遍历输出的` DOM 内容非常简单`，或者是`刻意依赖默认行为以获取性能上的提升`。因为它是 Vue 识别节点的一个通用机制，key 并不与 v-for 特别关联，key 还具有其他用途。

  - 不用key：
  > 1. 就地复用节点
  > 2. 无法维持组件状态
  > 3. 可能带来性能下降  

  - 用key：
  > 1. 维持组件状态，保证组件复用
  > 2. 查找性能上提升
  > 3. 节点复用带来的性能提升

7. `['1', '2', '3'].map(parseInt)` 返回什么 ？why ？[MDN中map定义](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map) [MDN中parseInt定义](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseInt)
```js
['1', '2', '3'].map(parseInt) // [1,NaN,NaN]
// 首先了解map中函数中参数，
// arr.map(function callback(currentValue, index, array)
// currentValue: 正在处理的当前函数
// index: 当前元素的索引
// array: 调用map方法的数组

// 再来看parseInt的参数
// parseInt(string, radix)
// string: 要被解析的值，如果不是字符串 会被转化为字符串
// radix: 一个介于2到36的的整数，在radix为undefined或0或未指定情况下，加遵守如下规则：
// 1. 如果字符串 string 以"0x"或者"0X"开头, 则基数是16 (16进制)
// 2. 如果字符串 string 以"0"开头, 基数是8（八进制）或者10（十进制），那么具体是哪个基数由实现环境决定。ECMAScript 5 规定使用10，但是并不是所有的浏览器都遵循这个规定。因此，永远都要明确给出radix参数的值
// 3. 如果字符串 string 以其它任何值开头，则基数是10 (十进制)

// 所以 上述函数 相当于执行 如下
['1', '2', '3'].map((item, index) => {
  return parseInt(item, index)
})
// 依次返回 parseInt('1', 0)，parseInt('2', 1)，parseInt('3', 2)
// 所以返回[1, NaN, NaN]
```

8. 什么是防抖和节流？有何区别？如何实现？
> 1. 防抖：n秒内函数只会执行一次，如果n秒内再次触发，则重新计算时间
> > 思路：每次事件触发事件就取消之前的延时调用
> ```js
> function debounce(fn) {
>   let timeout = null;
>   return function() {
>     clearTimeout(timeout);
>     timeout = setTimeout(() => {
>       fn.apply(this, arguments)
>     }, 500) 
>   }
> }
> ```
> 2. 节流：n秒内只会触发一次，节流会稀释函数的执行频率
> > 思路：每次触发事件时，都判断当前是否有等待执行的延迟函数
> ```js
> function throttle(fn) {
>   let canRun = true;
>   return function () {
>     if (!canRun) return;
>     canRun = false;
>     setTimeout(() => {
>       fn.apply(this, arguments)
>       canRun = true
>     }, 500)
>   }
> }
> ```

9. Set, Map, WeakSet和WeakMap的区别，[ECMAScript 6 入门中的描述](https://es6.ruanyifeng.com/#docs/set-map)
> 1. Set：成员不能重复，只有键值，没有键名，类似数组（length变为size），可枚举，有`add`  `delete` `has` `clear`等方法，`Array.from`方法可以将Set结构转化为数组
> 2. WeakSet：将弱引用对象储存在一个集合中，`只能存放对象引用，不能存放值`，有`add` `has` `delete`方法
> 3. Map：构建时应传入可枚举对象，类似对象，键名不再局限于自字符串，有`set` `get` `delete` `has` `clear` 等方法，有size属性，遍历map用[key, value] of map, 或者 forEach((value, key) => {})
> 4. WeakMap：和Map类似，但是其中的`键是弱引用`对象，值可以是任意的，因为可能被垃圾回收，所以`WeakMap的key是不可枚举的`，有`has` `get` `set` `delete`等方法

10. JS运行机制：
> - 执行流程图如下
> > ![Event Loop事件循环](./images/EventLoop事件循环.png)
> > 1. 整体的script(作为第一个宏任务)开始执行的时候，会把所有代码分为两部分：“同步任务”、“异步任务”
> > 2. 同步任务会直接进入主线程依次执行
> > 3. 异步任务会再分为宏任务和微任务
> > 4. 宏任务进入到Event Table中，并在里面注册回调函数，每当指定的事件完成时，Event Table会将这个函数移到Event Queue中
> > 5. 微任务也会进入到另一个Event Table中，并在里面注册回调函数，每当指定的事件完成时，Event Table会将这个函数移到Event Queue中
> > 6. 当主线程内的任务执行完毕，主线程为空时，会检查微任务的Event Queue，如果有任务，就全部执行，如果没有就执行下一个宏任务
> > 7. 上述过程会不断重复，这就是Event Loop事件循环
> - 关于`同步任务`和`异步任务`
> > 1. 同步任务：在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务
> > 2. 异步任务：不进入主线程，而进入“任务队列”，只有任务队列通知主线程，某个异步任务可以执行了，该任务才会到主线程中执行。  
> > ⚠️  `new Promise`会进入主线程立即执行，`Promise.then()`则属于`微任务`  
> > ⚠️  同样注意`async/await`，async函数返回的是一个Promise，所以在`await`行及以上内容会立即执行，await后的内容则相当于`promise.then`里的内容，属于微任务
> - 关于`Microtask`和`Macrotask/task`
> > 1. Microtask 微任务
> > - process.nexrtTick
> > - promise.then
> > - Object.observe(废弃)
> > - MutationObserver
> > 2. Macrotask 宏任务
> > - setTimeout / setInterval
> > - setImmediate
> > - I/O
> > - UI渲染

11. 有`var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10];`数组，要求数组扁平化并去除其中重复数据，最终得到一个升序且不重复的数组
> ```js
> // 首先要用到Array.flat()函数
> // flat()方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。
> 
> // 1. 先扁平化处理
> let tempArr = arr.flat(Infinity)
> // 2. 去重
> let tempSet = new Set(tempArr)
> // 3. 转为数组 再排序
> Array.from(tempSet).sort((a,b) => a - b)
> // 简化合并后
> Array.from(new Set(arr.flat(Infinity))).sort((a, b) => a - b)
> ```

12. `Object.create` 创建一个新对象，使用现有的对象来提供新创建的对象的`__proto__`，[MDN上说明](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create)， 关于`__proto__`属性，是用来读取或设置当前对象的prototype对象，目前只有浏览器环境下必须要部署这个属性。
> 参数：
> > - `proto` 必选， 新创建的原型对象
> > - `propertiesObject` 可选，需要传入一个对象，对象属性类型参照[Object.defineProperties](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties)，如果该参数不为`undefined`，该传入对象的自有可枚举属性（及其自身的定义属性，而不是其原型链上的枚举属性）将为新创建的对象添加指定的属性值和对应的属性描述符
> ```js
> let testObj = Object.create({}, {a: { value: 123 }, b: { value: "123" }})
> // 注意区分 new Object() 和 Object.create()的区别
> let a = { test: 123 }
> let b = new Object(a)
> let c = Object.create(a)
> b.hasOwnProperty("test")  // true
> b.__proto__ === Object.prototype // true
> c.hasOwnProperty("test")  // false
> c.__proto__  // { test: 123 }
> 
> // 延伸，如何显示一个new功能
> function (fn, ...arg) {
>   const obj = Object.create(fn.prototype)
>   const ret = fn.apply(obj, arg);
>   // ⚠️ 因为Object.create(null)创建的对象是不继承Object原型链上的属性的
>   // ⚠️ 通过 {} 和 new Object()创建的对象是一样是要继承的
>   // instanceof 用于检测构造函数的prototype属性是否出现在某个实例对象的原型链上
>   return ret instanceof Object ? ret : obj
> }
> 
> ```

13. TCP的三次握手和四次挥手理解
> - 流程如下图
> ![握手和挥手图](./images/TCP的三次握手和四次挥手.png)

14. 三种判断数组的方法和优劣：`Object.prototype.toString.call()`、`instanceof `、`Array.isArray()`
> 1. `Object.prototype.toString.call()`，适用范围最广
> ```js
> let a = []
> Object.prototype.toString.call(a) // [object Array]
> 
> Object.prototype.toString.call(1) // "[object Number]"
> Object.prototype.toString.call(Symbol(1)) // "[object Symbol]"
> Object.prototype.toString.call(null) // "[object Null]"
> Object.prototype.toString.call(undefined) // "[object Undefined]"
> ```
> 2. `instanceof`，它会在该对象的原型链上找对应的`Array`的原型
> ```js
> [] instanceof Array // true
> [] instanceof Object // true
> ```
> 3. `Array.isArray()`，性能最好，但要考虑兼容性

15. 浏览器渲染原理：JavaScript引擎是基于事件驱动单线程执行的，渲染线程负责渲染浏览器界面，但是GUI渲染线程与JS引擎是互斥的，当JS引擎执行时GUI线程会被挂起，GUI的更新也会被保存在一个队列中，等到JS引擎空闲时才有机会被执行，当浏览器获取HTML文件后，会自上而下加载并在加载过程中进行解析和渲染；加载就是获取资源的过程；`如果在加载过程中遇到外部的css文件和图片，浏览器会另外发送一个请求，去获取css文件和图片，这个请求是异步的，并不会影响HTML文件的加载；但如果遇到JavaScript文件，HTML文件会挂起渲染的进程`，等待JavaScript文件加载完毕后，再继续进行渲染
> 总体流程：`解析html` -> `构建DOM树` -> `构建CSSOM树` -> `构建渲染树` -> `布局` -> `绘制`
> 常见问题
>
> 1. 为什么要等待JS？
> > 因为JS可能会修改DOM，导致后面的HTML资源白白渲染，需要等待JS文件加载完成后，再继续渲染
> 2. CSS加载会阻塞页面显示吗？
> > 1. 不会阻塞DOM树的解析
> > 2. 会阻塞DOM树的渲染
> > 3. 会阻塞后面JS的语句的运行

16. 回流和重绘：

17. `观察者模式`和`发布订阅模式`的差异:

![差异图](./images/观察者模式和发布订阅模式的区别.png)
> 文字总结：
>
> > 1. 观察者模式中，观察者是知道Subject的。发布订阅模式中，发布者和订阅者是不知道对方存在的，只能通过消息代理
> > 2. 发布订阅模式中，组件是松散耦合的
> > 3. 观察者模式 大多数时候是同步的，发布订阅模式 大多是异步的
> >
> 高亮回答： 观察者模式中没有中间商，发布订阅模式有

18. 理解`vertical-align`和`line-height`的小细节，[参考链接](https://www.zhangxinxu.com/wordpress/2015/08/css-deep-understand-vertical-align-and-line-height/?shrink=1)
> 总结： 一个`inline-block`元素，如果里面的没有行内元素，或者overflow不为visible，则该元素的基线就是其margin底部的下边缘，否则就是最后一行内联元素的基线
>
> 其它：
> 1. vertical-align的默认值是`baseline`，且它只对行内元素起作用，对块级元素无感
> 2. vertical-align: middle的居中不是绝对的居中，是近似居中，因为是以文本的中线位置情况来的，如下图所示
>
> ![vertical-align:middle近似居中](./images/vertical-align_middle近似居中.png)
>
> 3. 可用`font-size: 0`来去掉内联元素的空白
> ```css
> /* vertical-align和line-height的联系 */
> {
> 	line-height: 30px; 
> 	vertical-align: -10%;
> }
> /* 等于如下 */
> {
> 	line-height: 30px; 
> 	vertical-align: -3px;
> }
> ```

19. `const`和`let`声明的变量不在`window`上，用`var`和`function`声明的变量和方法会出现在`window`上
20. 将数组`['A1', 'A2', 'B1', 'B2', 'C1', 'C2', 'D1', 'D2']`和数组`['A', 'B', 'C', 'D']`合并为`["A1", "A2", "A", "B1", "B2", "B", "C1", "C2", "C", "D1", "D2", "D"]`
```js
  // 方法1 （思路：将b数组加入大的标志值，合并排序后再清除标志值）
  let a = ['A1', 'A2', 'B1', 'B2', 'C1', 'C2', 'D1', 'D2'];
  let b = ['A', 'B', 'C', 'D'].map(item => item + '3');
  let res = [...a, ...b].sort().map(item => {
    if (item.includes('3')) return item.replace('3', '')
    return item
  })
  // 方法2 (思路：遍历a数组，当遇到要插入位置时，及尾号为2时，插入b数组元素，最后数组压平处理)
  let a = ['A1', 'A2', 'B1', 'B2', 'C1', 'C2', 'D1', 'D2'];
  let b = ['A', 'B', 'C', 'D'];
  let copyB = b;
  let res = a.map(item => {
    if (item.charAt(1) === '2') {
      return [item, copyB.shift()]
    }
    return item;
  }).flat();
  
````
21. `token`和`cookie`：
> 1. token不是用来防止`XSS(跨站脚本攻击)`，而是用来防止`CRSF(跨站请求伪造)`
> 2. CRFS的原因是浏览器会自动带上cookie，而不会自动带上`token`

22. vue中`defineProperty`和`Proxy`和区别：
> 一句话：Proxy能够劫持整个对象，而defineProperty只能劫持设置的对象属性，多了一层遍历
> ```js
> // defineProperty
> let obj = {};
> Object.defineProperty(obj, "name", {
> 	enumerable: true,
> 	set(value) {
> 		console.log("设置值了");
> 		_name = value
> 	},
> 	get() {
> 		console.log("取值了");
> 		return _name
> 	}
> })
> obj.age = 12; // 将不会提示
> 
> // Proxy
> let objProxy = new Proxy(obj, {
> 	get(obj, prop) {
> 		console.log("取值了");
> 		return obj[prop]
> 	},
> 	set(obj, prop, value) {
> 		console.log("设置值了");
> 		obj[prop] = value;
> 	}
> })
> objProxy.test = 123; // 会提示设置值了，obj中会出现test属性
> 
> ```

23. 下面函数的输出是？一句话`具名自执行函数，函数名可读且不能修改(const理解)`
```js
var b = 10;
(function b() {
  b = 20;
  console.log(b)
})();

// 输出如下：
// ƒ b() {
//  b = 20;
//  console.log(b)
// }

// 原因
// 内部作用域，会先去查找是有已有变量b的声明，有就直接赋值20，确实有了呀。发现了具名函数 function b(){}，拿此b做赋值；
// IIFE的函数无法进行赋值（内部机制，类似const定义的常量），所以无效。
```

24. 使用迭代方式实现`flat`函数
```js
// 1. 迭代方式
const arr = [1, 2, [3, 4]]
function flatten(arr) {
	while (arr.some(item => Array.isArray(item))) {
		arr = [].concat(...arr)
	}
	return arr
}
// some() 方法测试数组中是不是至少有1个元素通过了被提供的函数测试。它返回的是一个Boolean类型的值。

// 2. 递归方式
function flatten(arr) {
	let resArr = [];
	arr.forEach(item => {
		if (Array.isArray(item)) {
			resArr.push(...flatten(item));
		} else {
			resArr.push(item);
		}
	})
	return resArr
}
// 3. 字符串转换
arr.join(",").split(",").map(item => Number(item))
```

25. 下列代码什么情况下会打印1 ?
```js
var a;
if (a == 1 && a == 2 && a ==3) {
	console.log(1);
}

// 1. ==符号会进行隐式转换，所以可以改写toString 或者 valueOf方法
var a = {
	i: 0,
	// 转化为数字类型时 优先调用 valueOf
	valueOf() {
		return a.i++;
	},
	toString() {
		return a.i++;
	}
}

// 2. 如果a是数组，用数组的shift方法覆盖toString方法
var a = [1, 2, 3];
a.toString = a.shift

// 3. 可以用Symbal.toPrimitive
var a = {
	[Symbal.toPrimitive]: ((i) => () => i++)(0)
}
```

> 知识点：
> > 1. `toString`和`valueOf`的区别：
> > > toString：将对象的原始值以字符串形式返回
> > > valueOf： 返回最适合该对象的原始值
> > > 在数值运算中会优先调用`valueOf`，如 a + b
> > > 在字符串运算中会优先调用`toString`, 如 alert(a)
> >
> > 2. `Symbal.toPrimitive` 是一个内置的 Symbol 值，它是作为对象的函数值属性存在的，当一个对象转换为对应的原始值时，会调用此函数。[参看MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toPrimitive)

26. 了解BFC， `block formatting content(块级格式化上下文)`，具有BFC特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，[知乎文章参考](https://zhuanlan.zhihu.com/p/25321647)，[MDN文档参考](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flow_Layout/Intro_to_formatting_contexts)
> 只要元素满足下面任一条，即可触发BFC特性
> 1. html根元素（body不行）
> 2. 浮动元素：float 除 none 以外的值
> 3. 绝对定位元素：position (absolute、fixed)
> 4. display 为 inline-block、table-cells、flex
> 5. （🌟 最常用）overflow 除了 visible 以外的值 (hidden、auto、scroll) 
> - BFC特性及应用
> >  1. 同一个 BFC 下外边距会发生折叠
> >  2. BFC 可以包含浮动的元素（清除浮动）
> >  3. BFC 可以阻止元素被浮动元素覆盖

27. `React`复习知识点: 
> 1,  避免在`componentWillMount`中调用`setState`，因为该周期函数发生在`render`之前，这里设置`state`，是不会触发重新渲染的
>
> 2. 在react中手动添加的事件监听，需要在组件卸载时清除，否则会造成`内存泄漏`
> 3. 不传参时，函数绑定可以如下写: `<button onClick={::this.click}></button>`

28. `push`在伪数组中的一些使用，[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/push)
- 首先明确，push方式是一个通用的方法，可以在数组和伪数组中使用
- 判断一个变量是否是伪数组，需要如下条件
> 1. 不为空且是对象
> 2. 对象上的`splice`属性是函数类型
> 3. 对象上的`length`属性是正整数
> > 补充： `splice`可向数组中添加或删除项，返回值是裁剪下来的数组(若无裁剪 则返回空数组)，[w3school介绍](https://www.w3school.com.cn/jsref/jsref_splice.asp)，参数如下：
> > - index: 必须，添加或删除的位置，负数时是从结尾取
> > - howmany：必须，要删除的项目数量，如果为0，则不删除项
> > - item1... itemX：可选，向数组添加新项目
```js
// 思考如下输出
var obj = {
	'2': 3,
	'3': 4,
	'length': 2,
	'splice': Array.prototype.splice,
	'push': Array.prototype.push
}
obj.push(1) // { '2': 1, '3': 4, .... }
obj.push(2) // { '2': 1, '3': 4, .... }
```

29. `call`和`apply`有什么区别，哪一个性能更好？
- call和apply的作用是一样的，区别在于传入的参数不同
- 第一个参数都是指定指向内部的this
- apply第二个参数是指定数组或者类数组，call从第二个开始传入的参数是不固定的
- call的性能不apply好，call少了第二个参数的解构过程
- `call(this, ...params)`、`apply(this, [item1, item2, ...])`

30. 实现`(5).add(3).minus(2)`的功能
```js
Number.prototype.add = function(num) {
	// this或者this.valueOf()都可以
	return this.valueOf() + num
}
Number.prototype.minus = function(num) {
	return this.valueOf() - num
}
(5).add(3).minus(2) // 6
```
31. 如何让一个div水平垂直居中
```html
<div class="parent">
	<div class="child"></div>
</div>	
```
```css
/* 1. flex布局 */
.parent {
	display: flex;
	align-items: center;
	justify-content: center;
}
/* 或者 */
.parent {
	display: flex;
}
.child {
	margin: auto;
}
/* 2. relative和absolute */
.parent {
	position: relative;
}
.child {
	position: absolute;
	top: 50%;
	left: 50%;
	transform: translate(-50%, -50%);
}
/* 或者 */
.child {
	position: absolute;
	top: 0;
	left: 0;
	right: 0;
	bottom: 0;
	margin: auto;
}
/* 3. grid布局 */
.parent {
	display: grid;
}
.child {
	justify-self: center;
	align-self: center;
}
```
32. 用css画出三条横杠（⚠️主要考察`background-clip`指定背景绘制区域的使用）
```css
/* <div class="demo"></div> */
.demo {
	width: 100px;
	height: 10px;
	padding: 30px 0;
	border-top: 10px solid red;
	border-bottom: 10px solid red;
	background-color: red;
	background-clip: content-box;
}
```
33. 以下代码会输出什么，为什么？
```js
var a = { n: 1 }
var b = a
a.x = a = { n: 2 }
console.log(a.x) // undefined
console.log(b.x) // { n: 2 }
```
- 运算符`.`的优先级是高于`=`的，所以先执行`a.x`，此时`a.x = undefined`
- 而后`a`被指向新对象`{ n: 2}`，然后老对象的x指向此时a的新对象，所以此时老对象为`{ n: 1, x: { n: 2 } }`，新对象为`{ n: 2 }`
- 因为b一直指向老对象，所以会有如上输出

34. 某公司12月数据如下，`{ 1: 123, 5: 222, 11: 333 }`，希望转化为长度为12的数组形式`[123, null, ...]`，可如下操作
```js
let obj = { 1: 123, 5: 222, 11: 333 }
let res = Array.from({length: 12}, (it, index) => obj[index + 1] || null)
```
- 这里主要是考`Array.from`的使用，[MDN文档](https://developer.mozilla.org/zh-cn/docs/web/javascript/reference/global_objects/array/from)，参数如下：
> `arrayLike`：必选，伪数组或可迭代对象
> `mapFn`：可选，每个元素会执行的回调函数
> `thisArg`：可选，执行回调时`mapFn`的`this`对象

35. 已知如下代码，如何修改让图片宽度变为300px？代码不可修改
> ⚠️ `max-width`会覆盖`width`，`min-width`会覆盖`max-width`， [max-width MDN文档](https://developer.mozilla.org/zh-CN/docs/Web/CSS/max-width)
```html
<img src="a.jpg" style="width: 400px !important;" />
```
```css
/* 方案1 */
img {
	max-width: 300px;
}
/* 方案2 */
img {
	box-sizing: border-box;
	padding: 50px;
}
/* 方案3 */
img {
	transform: scale(0.75)
}
```

36. css中使用变量
```css
/* 申明变量时，带上--  */
:root {
	--color: #ff0000;
}
/* 注意变量名相同时的优先级问题  */
div {
	--color: #000000;
	color: var(--color);
}
```

37. less、sass善用mixin归类重复样式
```less
.line-camp( @clamp: 2 ) {
  display: -webkit-box;
  text-overflow: -o-ellipsis-lastline;
  overflow: hidden;
  text-overflow: ellipsis;
  -webkit-line-clamp: @clamp;
  -webkit-box-orient: vertical; 
}
.flex-box( @alignItems: 'normal', @justifyCtn: 'normal' ) {
	display: flex;
	align-items: @alignItems;
	justify-content: @justifyCtn;
}
```

38. 实现1px border方案
> 方案1的缺点是`老版本兼容性不太好`，方案2的缺点是`颜色要淡一些`
```css
/* 方案1 使用伪类 + transform */
.border_bottom {
	position: relative;
	overflow: hidden;
	border: none !important;
}
.border_bottom::after {
	display: block;
	content: " ";
	position: absolute;
	left: 0;
	bottom: 0;
	width: 100%;
	height: 1px;
	background: red;
	transform-origin: 0 0;
	tramsform: scaleY(0.5)
}

/* 方案2 使用box-shadow模拟 */
.border_bottom {
/* x偏移量 | y偏移量 | 阴影模糊半径 | 阴影扩散半径 | 阴影颜色 */
	box-shadow: inset 0 -1px 1px -1px red;
}
```
39. 字符串大小写取反
```js
// 方法1
function processStr(str) {
	let arr = str.split('');
	let newArr = arr.map(item => {
		return item === item.toUpperCase() ? item.toLowerCase() : item.toUpperCase()
	})
	return newArr.join("")
}
// 方法2
function processStr(str) {
	return str.replace(/[a-zA-Z]/g,function(a){
		return /[a-z]/.test(a) ? a.toUpperCase() : a.toLowerCase();
  })
}
```
40. 字符串匹配问题，从长度为n的字符串S中，查找是否存在字符串T，T的长度是m，若存在则返回存在位置
```js
const S = '123#adc#12322'
const T = 'adc'

// 方法1 search方法
const find = (S, T) => {
	return S.search(T)
}
// 方法2 match方法
const find = (S, T) => {
	const matchCtn = S.match(T)
	return matchCtn ? matchCtn.index : -1
}
// 方法3 substr (form, length)
const find = (S, T) => {
	if (S.length < T.length) return -1
	for (let i = 0; i < S.length - T.length; i++) {
		if (S.substr(i, T.length) === T) return i
	}
	return -1
}
```

41. `for`和`forEach`的性能比较，结果：`量级较小时，forEach更快`
```js
let arrs = new Array(100000);
console.time('for');
for (let i = 0; i < arrs.length; i++) {};
console.timeEnd('for');

console.time('forEach');
arrs.forEach((arr) => {});
console.timeEnd('forEach');

// node环境下，chrome下差不多
// 10w长度时 for: 2.269ms forEach: 0.323ms
// 100w长度时 for: 3.306ms forEach: 3.088ms
```
42. 关于`IFC(内联格式化上下文)`的知识点，不受竖直方向的padding/margin的影响，⚠️ IFC中不可能有块级元素，当插入块级元素时 会产生两个匿名块将块级元素分开

43. [Reflect](https://developer.mozilla.org/zh-cn/docs/web/javascript/reference/global_objects/reflect)，是一个内置对象，提供拦截js操作的方法
```js
let obj = {
  a: 1,
  b: 2
}
Reflect.get(obj, "b") // 2
Reflect.set(obj, "c", 123) // true  obj={ a: 1, b:2, c: 123 }
```
43. 输出1-10000之间所有的对称数，例如121、1331等
```js
// 思路 数字 ->字符串数组 -> 反转 -> 与原数字比较
[...Array(1000).keys()].filter(x => {
  return x.toString().length > 1 && x === Number(x.toString().split('').reverse().join(''))
})
```

44. 移动`0`，给定一个nums数组，将所有0移动到数组末尾，同时保持非零元素的相对顺序，要求：`原数组上操作，不能拷贝额外数组`、`尽量减少操作次数`
```js
let nums = [0, 1, 0, 2, 0, 3, 0, 0, 4]
for (let i = nums.length; i >= 0; i--) {
  if (nums[i] === 0) {
    nums.splice(i, 1)
    nums.push(0)
  }
}
```

45. 实现一个add函数，满足如下功能
```js
add(1) // 1
add(1)(2) // 3
add(1, 2)(3) // 6

// 实现
function add() {
  let args = [...arguments]
  let addFun = function() {
    return add.apply(null, [...args, ...arguments])
  }
  addFun.toString = function () {
    return args.reduce((a, b) => a + b)
  }
  return addFun
}
```

46. react-router里的`link`标签和`a`标签有什么区别，从最终结果上来看：`两者渲染出来都是a标签`
> link是react-router接管了链接跳转行为，阻止了默认跳转事件，链接变了，但不会刷新页面
> a普通的跳转链接

47. 给定一个整数数组和一个目标值，找出数组中和为目标值的两个数
> 例如给定 `nums = [2, 7, 11, 15]`，`target = 9`，返回`[0,1]`
```js
function answer(arr, target) {
  for (let i = 0; i < arr.length; i++) {
    for(let j = i + 1; j < arr.length; j++) {
      if (arr[j] === target - arr[i]) {
        return [i, j]
      }
    }
  }
  return "not found"
}
```

48. 写一个函数，输入整数类型，返回整数逆序后的字符串。要求使用递归，不能使用全局变量，输入函数必须只有一个函数传入，必须返回字符串
```js
function fun(num) {
  let num1 = num / 10;
  let num2 = num % 10;
  if (num1 < 1) {
    return num
  } else {
    return "" + num2 + fun(Math.floor(num1))
  }
}
```

49. 写出如下代码打印结果
```js
function Foo() {
  Foo.a = function() {
    console.log(1)
  }
  this.a = function() {
    console.log(2)
  }
}
// 以上只是Foo的构造方法，没有产生实例，此刻也没有执行
Foo.prototype.a = function() {
  console.log(3)
}
// 现在原型上挂载了a方法，方法输出3
Foo.a = function() {
  console.log(4)
}
// 现在Foo上挂载了直接方法a
Foo.a();
// 立即执行Foo上的a方法
let obj = new Foo();
// 这里调用了Foo的构造方法，Foo的构造方法主要做了两件事
// 1. 将全局Foo的a方法直接替换为输出1的方法
// 2. 新对象上挂载直接方法a，输出值为2
obj.a();
// 因为有直接方法，不需要去访问原型链，所以使用this.a
Foo.a();
// 构造方法里已经替换了全局Foo上的a方法
```

50. 修改一下print函数，使之输出0到99，或者99到0
> 要求：
> 1. 只能修改`setTimeout`到`Math.floor(Math.random() * 1000)`的代码
> 2. 不能修改`Math.floor(Math.random() * 1000)`
> 3. 不能使用全局变量
```js
function print(n){
  setTimeout(() => {
    console.log(n);
  }, Math.floor(Math.random() * 1000));
}
for(var i = 0; i < 100; i++){
  print(i);
}

// 方法1， 立即执行函数
function print(n) {
  setTimeout((() => {
    console.log(n)
  }).call(n, []), Math.floor(Math.random() * 1000))
}
// 方法2，取巧，让随机数无效
function print(n){
  setTimeout(() => {
    console.log(n);
  }, 1,  Math.floor(Math.random() * 1000));
}
```

51. `URLSearchParams`对url上的查询字符串进行处理，[MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/URLSearchParams)
```js
let searchObj = new URLSearchParams("https://www.xx.cn/api?keyword=&level1=&local_batch_id=&elective=800,700&local_province_id=33")
searchObj.get("elective") // "800,700"
```


