1. 函数柯里化：慢慢凑齐参数，延迟函数的执行（先分期交钱，再交货）
```js
// ⚠️ 函数的length属性，表示该函数有多少个必须要传入的参数，及第一个默认参数前的所有参数

// 概念版
const curry = (fn, arr = []) => {
  return (...args) => {
    // 判断总参数是否与fn参数个数相等
    if ([...arr, ...args].length === fn.length) {
      return fn(...arr, ...args) // 扩展参数，调用fn
    } else {
      return curry(fn,[...arr, ...args]) //迭代，传入现有的所有参数
    }
  }
}
 
 // 最终版
const curry = ( fn, arr = []) => {
  return (...args) => {
    return ( a => a.length === fn.length ? fn(...a) : curry(fn, a))([...arr, ...args])
  }
}
let curryPlus = curry((a,b,c,d)=>a+b+c+d)
curryPlus(1,2,3)(4) //返回10
curryPlus(1,2)(4)(3) //返回10
curryPlus(1,2)(3,4) //返回10

```

2. call、apply、bind三兄弟
> 1. 接收的第一个参数都是要绑定的this的指向
> 2. apply的第二个参数是一个参数数组，call和bind后的参数作为实参按顺序传入
> 3. bind不会立即调用，其它两个会

⚠️  call和apply，在严格模式下，函数this的值就是call和apply的的第一个参数的值，非严格模式下，第一个参数的值指定为null或者undefined时，this会自动替换指向全局对象，原始值会自动包装

```js
const developer = {
  getSkills: function(...args) {
    console.log(...args)
  }
}
const webDeveloper = {
  skills: ['html']
}
	
developer.getSkills.call(webDeveloper, 'h5', 'css3', 'js')
developer.getSkills.apply(webDeveloper, ['h5', 'css3', 'js'])
developer.getSkills.bind(webDeveloper)( 'h5', 'css3', 'js')
// 或者
developer.getSkills.bind(webDeveloper, 'h5', 'css3', 'js')()
```
3. 在局部作用域下，`undefined`是可以修改值的，所以局部作用域下，判断一个变量是否为`undefined`，更严谨的方法是 `typeof a === 'undefined'` 或者 `a === void(0)` 

🚩 为啥使用 `void` ?  void通常用于获取undefined的原始值，一般使用 `void(0)`或者`void 0`，因为`void`是不能被重写的 🌟  
🚩 全局作用域下，undefined不能被修改实际上是，`window.undefined`不能被修改，因为浏览器下任何全局变量都是在window下的，`let undefined = 3`会提示已经被定义
```js
function test() {
  let undefined = 3
  console.log(undefined)
}
test() // 3
```
4. HTTP 1.0/1.1/2.0 了解
> 相关链接：
>> [1.1和2.0的性能区别](https://http2.akamai.com/demo)  
>> [HTTP/2 相比 1.0 有哪些重大改进？](https://www.zhihu.com/question/34074946)

> HTTP 1.0特点：  
>> 1. 规定浏览器和服务器直接只能保持`短暂连接`，每次请求都要建立一个`TCP`连接，完成后立即断开，文件请求较多时，频繁建立和关闭连接比较费时
>> 2. 不跟踪每个用户，也不记录过去的请求，1.0 被抱怨最多的就是 `🌟连接无法复用`和`🌟head of line blocking（线头阻塞）`
>> 3. tips: `连接无法复用`会导致每次请求都经历三次握手和慢启动，三次握手在高延迟环境下影响明显，慢启动会对大文件请求影响较大。`线头阻塞`会导致带宽无法充分利用，后续健康请求被阻塞

> HTTP 1.1特点： 
>> 1. `支持持久连接`
>> 2. 可以一个TCP上可以传送多个HTTP请求和响应，允许客户端不用等待上一个请求结果返回，就可以发送下一次请求，但服务端必须按顺序响应结果，但是这个Pipelining在浏览器中是默认关闭的，因为 一些服务器不能正确处理 HPPT Pipelining，正确的流水线实现是很复杂的，如果某个请求花费太多时间，容易发生`线头阻塞`
>> 3. tips: 浏览器可以对同一Host的tcp请求的数量做限制，chrome为最多同时6个

> HTTP 2.0特点：
>
> > 1. `多路复用`：允许同时通过单一的 HTTP/2连接发起多重的请求-响应消息，实现多流并行而不依赖建立多个TCP连接
> > 2. `二进制分帧`：在应用层(HTTP/2)和传输层(TCP or UDP)之间增加一个二进制分帧层，将所有传输的信息分割为更小的消息和帧（frame）,并对它们采用二进制格式的编码 ，其中 HTTP1.x 的首部信息会被封装到 HEADER frame，而相应的 Request Body 则封装到 DATA frame 里面
> > 3. `首部压缩`
> > 4. `服务端推送`

5. HTTPS 加密握手过程，过程如下: 
![流程图](./images/HTTPS握手流程.png)
> HTTP有哪些缺点？ 无法保证消息的`保密性` `完整性` `准确性` `可靠性`，用明文在浏览器和服务器间传递信息  
> HTTPS 采用`对称加密`和`非对称加密`结合的方式，`对称加密算法加密数据`+`非对称加密算法交换密钥`+`数字证书验证身份`=`安全`

6. 关于vue中列表组件中使用key的讨论
> 1. vue在渲染列表的时候，采用就地复用的策略，如果dom的顺序修改，vue不会对dom的顺序做修改，而是复用当前元素，如 a,b,c,d,e中 bc间插入f，那么不带key的情况下，对照关系为 a->a, b->b, f->c, c->d, d->e, e
> 2. 官方文档中也提及：建议尽可能在使用 v-for 时提供 key，除非遍历输出的` DOM 内容非常简单`，或者是`刻意依赖默认行为以获取性能上的提升`。因为它是 Vue 识别节点的一个通用机制，key 并不与 v-for 特别关联，key 还具有其他用途。

  - 不用key：
  > 1. 就地复用节点
  > 2. 无法维持组件状态
  > 3. 可能带来性能下降  

  - 用key：
  > 1. 维持组件状态，保证组件复用
  > 2. 查找性能上提升
  > 3. 节点复用带来的性能提升

7. `['1', '2', '3'].map(parseInt)` 返回什么 ？why ？[MDN中map定义](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map) [MDN中parseInt定义](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseInt)
```js
['1', '2', '3'].map(parseInt) // [1,NaN,NaN]
// 首先了解map中函数中参数，
// arr.map(function callback(currentValue, index, array)
// currentValue: 正在处理的当前函数
// index: 当前元素的索引
// array: 调用map方法的数组

// 再来看parseInt的参数
// parseInt(string, radix)
// string: 要被解析的值，如果不是字符串 会被转化为字符串
// radix: 一个介于2到36的的整数，在radix为undefined或0或未指定情况下，加遵守如下规则：
// 1. 如果字符串 string 以"0x"或者"0X"开头, 则基数是16 (16进制)
// 2. 如果字符串 string 以"0"开头, 基数是8（八进制）或者10（十进制），那么具体是哪个基数由实现环境决定。ECMAScript 5 规定使用10，但是并不是所有的浏览器都遵循这个规定。因此，永远都要明确给出radix参数的值
// 3. 如果字符串 string 以其它任何值开头，则基数是10 (十进制)

// 所以 上述函数 相当于执行 如下
['1', '2', '3'].map((item, index) => {
  return parseInt(item, index)
})
// 依次返回 parseInt('1', 0)，parseInt('2', 1)，parseInt('3', 2)
// 所以返回[1, NaN, NaN]
```

8. 什么是防抖和节流？有何区别？如何实现？
> 1. 防抖：n秒内函数只会执行一次，如果n秒内再次触发，则重新计算时间
> > 思路：每次事件触发事件就取消之前的延时调用
> ```js
> function debounce(fn) {
>   let timeout = null;
>   return function() {
>     clearTimeout(timeout);
>     timeout = setTimeout(() => {
>       fn.apply(this, arguments)
>     }, 500) 
>   }
> }
> ```
> 2. 节流：n秒内只会触发一次，节流会稀释函数的执行频率
> > 思路：每次触发事件时，都判断当前是否有等待执行的延迟函数
> ```js
> function throttle(fn) {
>   let canRun = true;
>   return function () {
>     if (!canRun) return;
>     canRun = false;
>     setTimeout(() => {
>       fn.apply(this, arguments)
>       canRun = true
>     }, 500)
>   }
> }
> ```

9. Set, Map, WeakSet和WeakMap的区别，[ECMAScript 6 入门中的描述](https://es6.ruanyifeng.com/#docs/set-map)
> 1. Set：成员不能重复，只有键值，没有键名，类似数组（length变为size），可枚举，有`add`  `delete` `has` `clear`等方法，`Array.from`方法可以将Set结构转化为数组
> 2. WeakSet：将弱引用对象储存在一个集合中，`只能存放对象引用，不能存放值`，有`add` `has` `delete`方法
> 3. Map：构建时应传入可枚举对象，类似对象，键名不再局限于自字符串，有`set` `get` `delete` `has` `clear` 等方法，有size属性，遍历map用[key, value] of map, 或者 forEach((value, key) => {})
> 4. WeakMap：和Map类似，但是其中的`键是弱引用`对象，值可以是任意的，因为可能被垃圾回收，所以`WeakMap的key是不可枚举的`，有`has` `get` `set` `delete`等方法

10. JS运行机制：
> - 执行流程图如下
> > ![Event Loop事件循环](./images/EventLoop事件循环.png)
> > 1. 整体的script(作为第一个宏任务)开始执行的时候，会把所有代码分为两部分：“同步任务”、“异步任务”
> > 2. 同步任务会直接进入主线程依次执行
> > 3. 异步任务会再分为宏任务和微任务
> > 4. 宏任务进入到Event Table中，并在里面注册回调函数，每当指定的事件完成时，Event Table会将这个函数移到Event Queue中
> > 5. 微任务也会进入到另一个Event Table中，并在里面注册回调函数，每当指定的事件完成时，Event Table会将这个函数移到Event Queue中
> > 6. 当主线程内的任务执行完毕，主线程为空时，会检查微任务的Event Queue，如果有任务，就全部执行，如果没有就执行下一个宏任务
> > 7. 上述过程会不断重复，这就是Event Loop事件循环
> - 关于`同步任务`和`异步任务`
> > 1. 同步任务：在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务
> > 2. 异步任务：不进入主线程，而进入“任务队列”，只有任务队列通知主线程，某个异步任务可以执行了，该任务才会到主线程中执行。  
> > ⚠️  `new Promise`会进入主线程立即执行，`Promise.then()`则属于`微任务`  
> > ⚠️  同样注意`async/await`，async函数返回的是一个Promise，所以在`await`行及以上内容会立即执行，await后的内容则相当于`promise.then`里的内容，属于微任务
> - 关于`Microtask`和`Macrotask/task`
> > 1. Microtask 微任务
> > - process.nexrtTick
> > - promise.then
> > - Object.observe(废弃)
> > - MutationObserver
> > 2. Macrotask 宏任务
> > - setTimeout / setInterval
> > - setImmediate
> > - I/O
> > - UI渲染

