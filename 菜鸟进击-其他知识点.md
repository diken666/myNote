1. HTTP 1.0/1.1/2.0 了解
> 相关链接：
> > [1.1和2.0的性能区别](https://http2.akamai.com/demo)  
> > [HTTP/2 相比 1.0 有哪些重大改进？](https://www.zhihu.com/question/34074946)

> HTTP 1.0特点：  
> > 1. 规定浏览器和服务器直接只能保持`短暂连接`，每次请求都要建立一个`TCP`连接，完成后立即断开，文件请求较多时，频繁建立和关闭连接比较费时
> > 2. 不跟踪每个用户，也不记录过去的请求，1.0 被抱怨最多的就是 `🌟连接无法复用`和`🌟head of line blocking（线头阻塞）`
> > 3. tips: `连接无法复用`会导致每次请求都经历三次握手和慢启动，三次握手在高延迟环境下影响明显，慢启动会对大文件请求影响较大。`线头阻塞`会导致带宽无法充分利用，后续健康请求被阻塞

> HTTP 1.1特点： 
> > 1. `支持持久连接`
> > 2. 可以一个TCP上可以传送多个HTTP请求和响应，允许客户端不用等待上一个请求结果返回，就可以发送下一次请求，但服务端必须按顺序响应结果，但是这个Pipelining在浏览器中是默认关闭的，因为 一些服务器不能正确处理 HPPT Pipelining，正确的流水线实现是很复杂的，如果某个请求花费太多时间，容易发生`线头阻塞`
> > 3. tips: 浏览器可以对同一Host的tcp请求的数量做限制，chrome为最多同时6个

> HTTP 2.0特点：重要概念就是`流`和`帧`，帧属流，一TCP中多流，解决了以往的`串行文件传输`和`连接数过多`的问题
>
> > 1. `多路复用`：允许同时通过单一的 HTTP/2连接发起多重的请求-响应消息，实现多流并行而不依赖建立多个TCP连接
> > 2. `二进制分帧`：在应用层(HTTP/2)和传输层(TCP or UDP)之间增加一个二进制分帧层，将所有传输的信息分割为更小的消息和帧（frame）,并对它们采用二进制格式的编码 ，其中 HTTP1.x 的首部信息会被封装到 HEADER frame，而相应的 Request Body 则封装到 DATA frame 里面
> > 3. `首部压缩`
> > 4. `服务端推送`

2. HTTPS 加密握手过程，过程如下: 
![流程图](./images/HTTPS握手流程.png)
> HTTP有哪些缺点？ 无法保证消息的`保密性` `完整性` `准确性` `可靠性`，用明文在浏览器和服务器间传递信息  
> HTTPS 采用`对称加密`和`非对称加密`结合的方式，`对称加密算法加密数据`+`非对称加密算法交换密钥`+`数字证书验证身份`=`安全`

3. 关于vue中列表组件中使用key的讨论
> 1. vue在渲染列表的时候，采用就地复用的策略，如果dom的顺序修改，vue不会对dom的顺序做修改，而是复用当前元素，如 a,b,c,d,e中 bc间插入f，那么不带key的情况下，对照关系为 a->a, b->b, f->c, c->d, d->e, e
> 2. 官方文档中也提及：建议尽可能在使用 v-for 时提供 key，除非遍历输出的` DOM 内容非常简单`，或者是`刻意依赖默认行为以获取性能上的提升`。因为它是 Vue 识别节点的一个通用机制，key 并不与 v-for 特别关联，key 还具有其他用途。

  - 不用key：
  > 1. 就地复用节点
  > 2. 无法维持组件状态
  > 3. 可能带来性能下降  

  - 用key：
  > 1. 维持组件状态，保证组件复用
  > 2. 查找性能上提升
  > 3. 节点复用带来的性能提升

4. TCP的三次握手和四次挥手理解
> - 流程如下图
> ![握手和挥手图](./images/TCP的三次握手和四次挥手.png)

5. 浏览器渲染原理：JavaScript引擎是基于事件驱动单线程执行的，渲染线程负责渲染浏览器界面，但是GUI渲染线程与JS引擎是互斥的，当JS引擎执行时GUI线程会被挂起，GUI的更新也会被保存在一个队列中，等到JS引擎空闲时才有机会被执行，当浏览器获取HTML文件后，会自上而下加载并在加载过程中进行解析和渲染；加载就是获取资源的过程；`如果在加载过程中遇到外部的css文件和图片，浏览器会另外发送一个请求，去获取css文件和图片，这个请求是异步的，并不会影响HTML文件的加载；但如果遇到JavaScript文件，HTML文件会挂起渲染的进程`，等待JavaScript文件加载完毕后，再继续进行渲染
> 总体流程：`解析html` -> `构建DOM树` -> `构建CSSOM树` -> `构建渲染树` -> `布局` -> `绘制`
> 常见问题
>
> 1. 为什么要等待JS？
> > 因为JS可能会修改DOM，导致后面的HTML资源白白渲染，需要等待JS文件加载完成后，再继续渲染
> 2. CSS加载会阻塞页面显示吗？
> > 1. 不会阻塞DOM树的解析
> > 2. 会阻塞DOM树的渲染
> > 3. 会阻塞后面JS的语句的运行

6. 回流和重绘：

7. `观察者模式`和`发布订阅模式`的差异:

![差异图](./images/观察者模式和发布订阅模式的区别.png)
> 文字总结：
>
> > 1. 观察者模式中，观察者是知道Subject的。发布订阅模式中，发布者和订阅者是不知道对方存在的，只能通过消息代理
> > 2. 发布订阅模式中，组件是松散耦合的
> > 3. 观察者模式 大多数时候是同步的，发布订阅模式 大多是异步的
> >
> 高亮回答： 观察者模式中没有中间商，发布订阅模式有

8. `token`和`cookie`：
> 1. token不是用来防止`XSS(跨站脚本攻击)`，而是用来防止`CRSF(跨站请求伪造)`
> 2. CRFS的原因是浏览器会自动带上cookie，而不会自动带上`token`

9. `React`复习知识点: 
> 1,  避免在`componentWillMount`中调用`setState`，因为该周期函数发生在`render`之前，这里设置`state`，是不会触发重新渲染的
>
> 2. 在react中手动添加的事件监听，需要在组件卸载时清除，否则会造成`内存泄漏`
> 3. 不传参时，函数绑定可以如下写: `<button onClick={::this.click}></button>`

10. react-router里的`link`标签和`a`标签有什么区别，从最终结果上来看：`两者渲染出来都是a标签`

> link是react-router接管了链接跳转行为，阻止了默认跳转事件，链接变了，但不会刷新页面
> a普通的跳转链接