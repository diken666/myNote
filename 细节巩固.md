1. 函数柯里化：慢慢凑齐参数，延迟函数的执行（先分期交钱，再交货）
```js
// ⚠️ 函数的length属性，表示该函数有多少个必须要传入的参数，及第一个默认参数前的所有参数

// 概念版
const curry = (fn, arr = []) => {
  return (...args) => {
    // 判断总参数是否与fn参数个数相等
    if ([...arr, ...args].length === fn.length) {
      return fn(...arr, ...args) // 扩展参数，调用fn
    } else {
      return curry(fn,[...arr, ...args]) //迭代，传入现有的所有参数
    }
  }
}
 
 // 最终版
const curry = ( fn, arr = []) => {
  return (...args) => {
    return ( a => a.length === fn.length ? fn(...a) : curry(fn, a))([...arr, ...args])
  }
}
let curryPlus = curry((a,b,c,d)=>a+b+c+d)
curryPlus(1,2,3)(4) //返回10
curryPlus(1,2)(4)(3) //返回10
curryPlus(1,2)(3,4) //返回10

```

2. call、apply、bind三兄弟
> 1. 接收的第一个参数都是要绑定的this的指向
> 2. apply的第二个参数是一个参数数组，call和bind后的参数作为实参按顺序传入
> 3. bind不会立即调用，其它两个会

⚠️  call和apply，在严格模式下，函数this的值就是call和apply的的第一个参数的值，非严格模式下，第一个参数的值指定为null或者undefined时，this会自动替换指向全局对象，原始值会自动包装

```js
const developer = {
  getSkills: function(...args) {
    console.log(...args)
  }
}
const webDeveloper = {
  skills: ['html']
}
	
developer.getSkills.call(webDeveloper, 'h5', 'css3', 'js')
developer.getSkills.apply(webDeveloper, ['h5', 'css3', 'js'])
developer.getSkills.bind(webDeveloper)( 'h5', 'css3', 'js')
// 或者
developer.getSkills.bind(webDeveloper, 'h5', 'css3', 'js')()
```
3. 在局部作用域下，`undefined`是可以修改值的，所以局部作用域下，判断一个变量是否为`undefined`，更严谨的方法是 `typeof a === 'undefined'` 或者 `a === void(0)` 

🚩 为啥使用 `void` ?  void通常用于获取undefined的原始值，一般使用 `void(0)`或者`void 0`，因为`void`是不能被重写的 🌟  
🚩 全局作用域下，undefined不能被修改实际上是，`window.undefined`不能被修改，因为浏览器下任何全局变量都是在window下的，`let undefined = 3`会提示已经被定义
```js
function test() {
  let undefined = 3
  console.log(undefined)
}
test() // 3
```
4. HTTP 1.0/1.1/2.0 了解
> 相关链接：
>> [1.1和2.0的性能区别](https://http2.akamai.com/demo)
>> [HTTP/2 相比 1.0 有哪些重大改进？](https://www.zhihu.com/question/34074946)

> HTTP 1.0特点：  
>> 1. 规定浏览器和服务器直接只能保持`短暂连接`，每次请求都要建立一个`TCP`连接，完成后立即断开，文件请求较多时，频繁建立和关闭连接比较费时
>> 2. 不跟踪每个用户，也不记录过去的请求，1.0 被抱怨最多的就是 `🌟连接无法复用`和`🌟head of line blocking（线头阻塞）`  

> HTTP 1.1特点： 
>> 1. `支持持久连接`
>> 2. 可以一个TCP上可以传送多个HTTP请求和响应，允许客户端不用等待上一个请求结果返回，就可以发送下一次请求，但服务端必须按顺序响应结果，但是这个Pipelining在浏览器中是默认关闭的，因为 一些服务器不能正确处理 HPPT Pipelining，正确的流水线实现是很复杂的，如果某个请求花费太多时间，容易发生`线头阻塞`
>> 3. tips: 浏览器可以对同一Host的tcp请求的数量做限制，chrome为最多同时6个

> HTTP 2.0特点：
>
> > 1. `多路复用`：允许同时通过单一的 HTTP/2连接发起多重的请求-响应消息，实现多流并行而不依赖建立多个TCP连接
> > 2. `二进制分帧`：在应用层(HTTP/2)和传输层(TCP or UDP)之间增加一个二进制分帧层，将所有传输的信息分割为更小的消息和帧（frame）,并对它们采用二进制格式的编码 ，其中 HTTP1.x 的首部信息会被封装到 HEADER frame，而相应的 Request Body 则封装到 DATA frame 里面
> > 3. `首部压缩`
> > 4. `服务端推送`