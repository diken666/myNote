1. 函数柯里化：慢慢凑齐参数，延迟函数的执行（先分期交钱，再交货）
```js
// ⚠️ 函数的length属性，表示该函数有多少个必须要传入的参数，及第一个默认参数前的所有参数

// 概念版
 const curry = (fn, arr = []) => {
 	return (...args) => {
 		// 判断总参数是否与fn参数个数相等
 		if ([...arr, ...args].length === fn.length) {
 			return fn(...arr, ...args) // 扩展参数，调用fn
 		} else {
 			return curry(fn,[...arr, ...args]) //迭代，传入现有的所有参数
 		}
 	}
 }
 
 // 最终版
 const curry = ( fn, arr = []) => {
 	return (...args) => {
 		return ( a => a.length === fn.length ? fn(...a) : curry(fn, a))([...arr, ...args])
 	}
 }
let curryPlus = curry((a,b,c,d)=>a+b+c+d)
curryPlus(1,2,3)(4) //返回10
curryPlus(1,2)(4)(3) //返回10
curryPlus(1,2)(3,4) //返回10

```

2. call、apply、bind三兄弟
> 1. 接收的第一个参数都是要绑定的this的指向
> 2. apply的第二个参数是一个参数数组，call和bind后的参数作为实参按顺序传入
> 3. bind不会立即调用，其它两个会

⚠️  call和apply，在严格模式下，函数this的值就是call和apply的的第一个参数的值，非严格模式下，第一个参数的值指定为null或者undefined时，this会自动替换指向全局对象，原始值会自动包装

```js
	const developer = {
		getSkills: function(...args) {
			console.log(...args)
		}
	}
	const webDeveloper = {
		skills: ['html']
	}
	
	developer.getSkills.call(webDeveloper, 'h5', 'css3', 'js')
	developer.getSkills.apply(webDeveloper, ['h5', 'css3', 'js'])
	developer.getSkills.bind(webDeveloper)( 'h5', 'css3', 'js')
	// 或者
	developer.getSkills.bind(webDeveloper, 'h5', 'css3', 'js')()
```
3. 在局部作用域下，`undefined`是可以修改值的，所以局部作用域下，判断一个变量是否为`undefined`，更严谨的方法是 `typeof a === 'undefined'` 或者 `a === void(0)` 

🚩 为啥使用 `void` ?  void通常用于获取undefined的原始值，一般使用 `void(0)`或者`void 0`，因为`void`是不能被重写的 🌟
🚩 全局作用域下，undefined不能被修改实际上是，`window.undefined`不能被修改，因为浏览器下任何全局变量都是在window下的，`let undefined = 3`会提示已经被定义
```js
	function test() {
		let undefined = 3
		console.log(undefined)
	}
	test() // 3
```